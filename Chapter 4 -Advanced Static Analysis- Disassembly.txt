Register notes simple instructions notes is written down. 

Basic arthimetic at register level: 

Addition- add destination and value. adds value to destination and stores the value in destination. Can it set zero flag? 
Substraction- sub destination and value- substracts value from destination ZF is set if result=0 CF is set if value> destination. 
inc- inc value. increment operator. 
dec- dec value. decrement operator. 
Multiplication and divison work on specific registers, so the instruction contains just the code and the multiplier and divisor. 
before the operations are called, registers has to be set properly before the operation takes place. 
mul value- Multiplies eax by value.  
The result is stored in two registers EDX(most significant 32 bits) and EAX(Least significant 32 bits). 

div value- it divides edx and eax by value and stores the quotient in eax and remainder in edx. 
modulo operation can be performed similarly and the result can be accessed by the edx register. 

imul and idiv are the signed equivalents of mul and div. 

Logical Operations: 
AND and OR work similar to add and substract and source destination result is stored in destination.  
AND- 
OR- 
XOR- encountered frequently as it is a quick way to set a register to zero. 
xor eax, eax takes 2 bytes but mov eax, 0 takes 5 bytes. 
Shr- shift right. shr destination, count. shifts destination to right by count number of times. 
shl-shift Left.  shl destination, count. shifts destination to left by count number of times.
Bits shifted out of the boundary are stored at CF flag first 
ror- rotate right.  
rol-rotate left. 

shifting left is a good substitute for multiplication shl eax, 1 is similar to multiplying eax by 2. 
 



Page Number 110 summry form https://see.stanford.edu/materials/icsppcs107/15-Function-Call-And-Return.pdf 

a call to a function creates an executable instance/activation of that function and hence is called an activation record. 
Each activation record needs the following information; 

1) local variables and arguments to the function. 
2) return address. 

However, there must be some convention followed by which the control and flow of information occurs from a calling function to the called function. 
Henceforth the stack;	

The stack: 

A stack DS uses LIFO order. 
Common operations include push, pop, call, leave, enter and ret. # Implemented in c. 
register support for stack are ESP and EBP 
ESP is the stack pointer- consists of a pointer which points to the top of the stack.  
EBP is the base pointer- points to variables and parmeters and stays consistent for one function. 

Function: 

A function is a block of code which has a specfic input and output and a group of statements executed together. 
Lets take two functions A and B, and below are our assumptions;

A calls B and the below things are going to happen; 

1) A pushes the space onto the stack for the parameters for the call. 
2) Parameters are loaded onto the stack
3) the caller saves return information(Old EBP and return address) 
4) The control flows to the called function, and beings by adding local variables onto the stack. 
5) the called function's instructions are executed and it has access to all of the resources in its AR. 
6) After all of the instructions are executed, its portion of the AR is popped of the stack 
7)  control returns to the old EBP and any output values are returned to the returned address and the 
parameters are popped of the stack.   
 

Conditionals: 

conditional statements are used to make decisions and most important of those statements are cmp(compare) and test. 
cmp is similar to add and test is similar to sub, but registers are not impacted. 

branching: 

branching is accomplished using jump instruction and is commonly executed after a test/cmp instruction. 
test/cmp instructions set the flags and jump instruction depend on the flags to decide if to jump; 

Rep instructions: 

they are used to maniulate data buffers and most common of them are movsb, cmpsb, stosb and scasb(b is for byte and can be replaced by w-word and d double byte).
ESI(source index) and EDI(destination index) registers are commonly used for these instructions. ECX works as a counting variable. 

movsb- copies one byte at address ESI and pastes it at address EDI. 
rep is used as a prefix to copy mutltiple bytes. 

DF- Direction flag is used to increment/decrement the addresses while copying. 

The process is described as below; 

if DF=0, 

1) ECX register is set to the number of registers to be copied(rep instruction is used to set the number of times movsb is to be used). 
2) rep movsb insruction is executed, movsb- copies one byte at address ESI and pastes it at address EDI.
3) ESI and EDI are both incremented by one. and ECX is decremented by one. 

if DF=1, ESI and EDI are decremented, rather than incremented. This is generally done to store data in a different direction. 
 

CMPSB: compares the bytes at ESI and EDI by substraction to check if both are same, but works similarly to movsb in other respects. 

SCASB- is used to look at a single value in the sequnce(Defined by AL register). 
It compares the value at EDI with AL. 

STOSB- store a specified value at the location specified by EDI. 
If used with repe- is is used to initialize a block of memory to a specific value until ECX=0. 


